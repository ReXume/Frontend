# 📊 PDF.js 벤치마크

## 🎯 벤치마크 종류

### 1. 📈 LongTask 벤치마크 (기본)
PDF.js의 sendWithPromise 호출과 LongTask를 추적하는 기본 벤치마크

### 2. 🔥 기기별 성능 벤치마크 (NEW!)
저사양/중사양/고사양 기기에서 현실적 사용자 패턴(스크롤 → 읽기 → 반복)으로 성능 비교

---

## 🚀 사용법

### 📈 LongTask 벤치마크

#### 단일 측정

```bash
npm run bench:longtask -- \
  --url1 "http://localhost:3000/feedback/4?version=pdf" --name1 "PDF-기본" \
  --url2 "http://localhost:3000/feedback/4?version=queue" --name2 "Queue-기본" \
  --realistic true
```

#### 반복 실행 (권장)

```bash
cd frontend/bench

# 10회 반복 (빠름 - 약 15-20분)
./run-10-tests.sh

# 25회 반복 (정확 - 약 35-50분)
./run-25-tests.sh

# 100회 반복 (장시간 - 약 2.5-3.5시간)
./run-100-tests.sh
```

---

### 🔥 기기별 성능 벤치마크 (NEW!)

> 🎯 **행동 패턴 고정**: bench-pdfjs-longtasks.js의 realistic 패턴과 동일
> - 스크롤 쭉 내리기 (300px씩, 50ms 간격)
> - 1.5초 멈춰서 읽기
> - 3번마다 위로 150px 스크롤 (다시 보기)
> - 반복

#### 데모 (처음 사용자용)

```bash
cd frontend/bench

# 초고속 데모 - 결과 형식 확인용 (2회, ~3분)
./demo-device-behavior.sh
```

#### 빠른 시작

```bash
cd frontend/bench

# 빠른 테스트 (2 기기 × 2 버전 = 4회, ~7분)
./run-device-behavior-test.sh quick

# 전체 테스트 (3 기기 × 2 버전 = 6회, ~10분)
./run-device-behavior-test.sh full
```

#### 세부 옵션

```bash
# 저사양 기기만 테스트
./run-device-behavior-test.sh low-device

# 중사양 기기만 테스트
./run-device-behavior-test.sh mid-device

# 고사양 기기만 테스트
./run-device-behavior-test.sh high-device
```

#### 직접 실행 (커스터마이징)

```bash
# 특정 기기만 선택
cd frontend
node bench/bench-device-behavior.js \
  --url1 "http://localhost:3000/feedback/4?version=pdf" --name1 "PDF" \
  --url2 "http://localhost:3000/feedback/4?version=queue" --name2 "Queue" \
  --devices "low,high"

# 단일 URL 테스트
cd frontend
node bench/bench-device-behavior.js \
  --url "http://localhost:3000/feedback/4?version=pdf" \
  --devices "low"
```

#### 지원되는 기기 프로필

| 기기 | CPU Throttle | 설명 |
|------|-------------|------|
| 🐌 `low` | 6x | 오래된 스마트폰, 저가형 노트북 |
| 🚗 `mid` | 3x | 일반 노트북, 중급 스마트폰 |
| 🚀 `high` | 1x | 최신 노트북, 플래그십 스마트폰 |

---

## 📊 결과 파일

### LongTask 벤치마크
**하나의 파일에 모든 결과 누적:**
- `bench/bench_out/benchmark-results.json`

#### 파일 구조

```json
{
  "lastUpdated": "2025-10-15T...",
  "totalMeasurements": 75,
  "measurements": [
    { "version": "PDF-기본", "sendWithPromiseCalls": [...], ... },
    { "version": "Queue-기본", "sendWithPromiseCalls": [...], ... },
    ...
  ],
  "averages": {
    "PDF-기본": {
      "count": 25,
      "sendWithPromise": { "avg": 28.5, "min": 24, "max": 33 },
      "longTasks": { "avg": 18.2, "min": 15, "max": 22 },
      "totalBlockingTime": { "avg": 756.9, ... },
      ...
    },
    "Queue-기본": { ... }
  }
}
```

### 기기별 성능 벤치마크
**타임스탬프별 파일 생성:**
- `bench/bench_out/device-behavior-YYYY-MM-DDTHH-mm-ss-sssZ.json`

#### 파일 구조

```json
{
  "timestamp": "2025-10-16T...",
  "config": {
    "devices": [
      { "key": "low", "name": "저사양 기기", "cpuThrottle": 6, ... },
      { "key": "high", "name": "고사양 기기", "cpuThrottle": 1, ... }
    ],
    "behavior": {
      "key": "realistic",
      "name": "현실적 사용자 패턴",
      "description": "bench-pdfjs-longtasks.js의 realistic 패턴과 동일"
    }
  },
  "totalTests": 4,
  "results": [
    {
      "testName": "PDF-🐌저사양 기기-🎯현실적 사용자 패턴",
      "version": "PDF",
      "device": "저사양 기기",
      "behavior": "현실적 사용자 패턴",
      "renderEfficiency": 0.65,
      "totalBlockingTime": 1234.5,
      "longTasks": 25,
      ...
    }
  ]
}
```

---

## 📈 출력 예시

### LongTask 벤치마크 - 시나리오별 평균

```
================================================================================
📊 시나리오별 평균 (전체 누적 데이터)
================================================================================

🔹 PDF-기본 (n=25)
────────────────────────────────────────────────────────────────────────────
   렌더링된 페이지:     평균 25.3개 (22~28)
   렌더링 효율:        평균 0.82 pages/sec (0.75~0.91)
   sendWithPromise:     평균 28.5회 (24~33)
   LongTask:           평균 18.2개 (15~22)
   Total Blocking Time: 평균 756.9ms (623~988)
   전체 시간:          평균 31.4s (28.3~35.7)

🔹 Queue-기본 (n=24, 제외: 1)
────────────────────────────────────────────────────────────────────────────
   렌더링된 페이지:     평균 32.8개 (29~36)  ← 30% 더 많이!
   렌더링 효율:        평균 1.12 pages/sec (1.05~1.23)  ← 36% 빠름!
   sendWithPromise:     평균 19.7회 (16~24)
   LongTask:           평균 9.5개 (7~12)
   Total Blocking Time: 평균 312.3ms (245~412)
   전체 시간:          평균 29.2s (26.1~32.8)


================================================================================
🔍 버전 비교 (평균)
================================================================================

📊 기본
────────────────────────────────────────────────────────────────────────────
   렌더링 페이지:    25.3개 → 32.8개         (✅ 29.6%)
   렌더링 효율:      0.82 → 1.12 pages/sec  (✅ 36.6%)
   TBT:              756.9ms → 312.3ms      (✅ 58.7%)
   LongTask:         18.2개 → 9.5개         (✅ 48.2%)
   sendWithPromise:  28.5회 → 19.7회        (✅ 30.9%)
```

---

### 기기별 성능 벤치마크 - 종합 분석

```
====================================================================================================
📊 종합 분석 결과 (현실적 사용자 패턴)
====================================================================================================

🔹 기기별 성능 비교
────────────────────────────────────────────────────────────────────────────────────────────────

🐌 저사양 기기 (n=2):
   평균 렌더링 효율: 0.68 pages/sec
   평균 TBT: 1523.5ms
   평균 LongTask: 29.5개
   평균 소요 시간: 44.2s

🚗 중사양 기기 (n=2):
   평균 렌더링 효율: 0.98 pages/sec
   평균 TBT: 856.8ms
   평균 LongTask: 19.0개
   평균 소요 시간: 36.7s

🚀 고사양 기기 (n=2):
   평균 렌더링 효율: 1.42 pages/sec
   평균 TBT: 423.1ms
   평균 LongTask: 10.5개
   평균 소요 시간: 29.3s


🔹 버전별 성능 비교
────────────────────────────────────────────────────────────────────────────────────────────────

PDF (n=3):
   평균 렌더링 효율: 0.87 pages/sec
   평균 TBT: 1245.3ms
   평균 LongTask: 24.8개
   평균 sendWithPromise: 32.7회

Queue (n=3):
   평균 렌더링 효율: 1.23 pages/sec
   평균 TBT: 624.5ms
   평균 LongTask: 12.3개
   평균 sendWithPromise: 19.8회


🔹 Best & Worst 기기 (Total Blocking Time 기준)
────────────────────────────────────────────────────────────────────────────────────────────────

✅ Best 3:
   1. 🚀고사양 기기 [Queue]
      TBT: 256ms, LongTask: 6개, 효율: 1.68 pages/sec
   2. 🚀고사양 기기 [PDF]
      TBT: 590ms, LongTask: 15개, 효율: 1.16 pages/sec
   3. 🚗중사양 기기 [Queue]
      TBT: 678ms, LongTask: 14개, 효율: 1.15 pages/sec

❌ Worst 3:
   1. 🐌저사양 기기 [PDF]
      TBT: 1978ms, LongTask: 42개, 효율: 0.52 pages/sec
   2. 🐌저사양 기기 [Queue]
      TBT: 1069ms, LongTask: 17개, 효율: 0.84 pages/sec
   3. 🚗중사양 기기 [PDF]
      TBT: 1035ms, LongTask: 24개, 효율: 0.81 pages/sec


====================================================================================================
🔍 버전 간 비교 (기기별)
====================================================================================================

🐌 저사양 기기 (현실적 패턴)
────────────────────────────────────────────────────────────────────────────────────────────────
메트릭                          PDF                 Queue               개선율
────────────────────────────────────────────────────────────────────────────────────────────────
렌더링 효율                     0.52 p/s            0.84 p/s            ✅ 61.5%
Total Blocking Time             1978ms              1069ms              ✅ -46.0%
LongTask 수                     42개                17개                ✅ -59.5%
sendWithPromise 호출            38회                22회                ✅ -42.1%
소요 시간                       52134ms             38256ms             ✅ -26.6%

🚗 중사양 기기 (현실적 패턴)
────────────────────────────────────────────────────────────────────────────────────────────────
메트릭                          PDF                 Queue               개선율
────────────────────────────────────────────────────────────────────────────────────────────────
렌더링 효율                     0.81 p/s            1.15 p/s            ✅ 42.0%
Total Blocking Time             1035ms              678ms               ✅ -34.5%
LongTask 수                     24개                14개                ✅ -41.7%
sendWithPromise 호출            31회                19회                ✅ -38.7%
소요 시간                       38567ms             32456ms             ✅ -15.8%

🚀 고사양 기기 (현실적 패턴)
────────────────────────────────────────────────────────────────────────────────────────────────
메트릭                          PDF                 Queue               개선율
────────────────────────────────────────────────────────────────────────────────────────────────
렌더링 효율                     1.16 p/s            1.68 p/s            ✅ 44.8%
Total Blocking Time             590ms               256ms               ✅ -56.6%
LongTask 수                     15개                6개                 ✅ -60.0%
sendWithPromise 호출            29회                18회                ✅ -37.9%
소요 시간                       28456ms             24789ms             ✅ -12.9%
```

---

## ⚙️ 옵션

| 옵션 | 설명 | 기본값 |
|------|------|--------|
| `--realistic` | 현실적 사용자 패턴 (스크롤→읽기) | false |
| `--cpu` | CPU throttling | 4 |
| `--delay` | 단계별 대기 (ms) | 500 |
| `--steps` | 스크롤 단계 | 10 |
| `--headless` | Headless 모드 | true |

---

## 💡 3가지 시나리오 차이점

### 1. 기본 환경 (중저사양 PC, 현실적 패턴)

**설정:** `--realistic true --cpu 4`

**동작:**
- 🖥️ CPU 4배 느림 (중저사양 PC 시뮬레이션)
- 📜 스크롤 쭉 내림 (300px씩 빠르게)
- 📖 1.5초 멈춰서 읽기
- 🔄 반복

**목적:** 일반 사용자 환경 (가장 많은 사용자)

---

### 2. 고사양 환경 (최신 PC, 현실적 패턴)

**설정:** `--realistic true --cpu 1`

**동작:**
- 🖥️ CPU 제약 없음 (고사양 PC)
- 📜 스크롤 쭉 내림 (300px씩 빠르게)
- 📖 1.5초 멈춰서 읽기
- 🔄 반복

**목적:** 최신 PC에서도 Queue가 효과 있는지 확인

**차이점:** CPU만 다름! (4배 vs 제약없음)

---

### 3. 천천히 읽기 (꼼꼼히 읽는 패턴)

**설정:** `--delay 2000 --steps 8`

**동작:**
- 🖥️ CPU 4배 느림
- 📜 8단계로 나눠서 스크롤
- ⏱️ 각 단계마다 2초 대기 (천천히)

**목적:** 사용자가 꼼꼼히 읽을 때의 성능

**차이점:** 스크롤 패턴이 다름! (현실적 패턴 vs 일정한 간격)

---

## 📊 비교표

| 시나리오 | CPU | 스크롤 방식 | 읽기 시간 | 시뮬레이션 환경 |
|---------|-----|------------|-----------|----------------|
| **기본** | 4배 | 쭉 내리고 읽기 반복 | 1.5초 | 대부분 사용자 |
| **고사양** | **1배** | 쭉 내리고 읽기 반복 | 1.5초 | 최신 PC |
| **느림** | 4배 | **일정한 간격** | **2초** | 꼼꼼히 읽기 |

---

## 🎯 왜 3가지를 측정하나?

### 기본 환경
→ **대부분의 사용자**가 이런 환경
→ 가장 중요한 시나리오!

### 고사양 환경  
→ **빠른 PC에서도 Queue가 효과있나?** 확인
→ CPU가 빠르면 차이가 줄어들 수 있음

### 천천히 읽기
→ **안정적인 환경**에서의 성능
→ 충분한 시간이 있을 때도 Queue가 나은지 확인

---

## 💡 예상 결과

**TBT 개선율 예상:**
- 기본 환경: ~60% (가장 큰 차이)
- 고사양: ~50% (차이 약간 줄어듦)
- 느림: ~35% (차이 더 줄어듦)

→ **느린 환경일수록 Queue의 효과가 크다!**

---

## 🔄 결과 관리

### LongTask 벤치마크 초기화

```bash
rm bench/bench_out/benchmark-results.json
```

새로 측정을 시작하고 싶을 때 사용하세요.

### 기기별 성능 벤치마크 파일 정리

```bash
# 오래된 결과 파일 삭제
rm bench/bench_out/device-behavior-*.json

# 최신 파일만 유지 (최근 3개)
ls -t bench/bench_out/device-behavior-*.json | tail -n +4 | xargs rm
```

---

## 💡 팁

### 어떤 벤치마크를 사용해야 하나요?

#### LongTask 벤치마크 (`bench-pdfjs-longtasks.js`) 사용 시점:
- ✅ **많은 반복 측정이 필요할 때** (통계적 신뢰도)
- ✅ **하나의 특정 시나리오를 깊게 분석**할 때
- ✅ **장기간 누적 데이터를 수집**할 때
- ✅ **CI/CD 파이프라인에 통합**할 때

#### 기기별 성능 벤치마크 (`bench-device-behavior.js`) 사용 시점:
- ✅ **저사양/중사양/고사양 기기 차이를 명확히** 파악하고 싶을 때
- ✅ **현실적 사용자 패턴에서의 성능 차이**를 분석할 때
- ✅ **최적화 전후 기기별 비교**를 확인할 때
- ✅ **기기 스펙에 따른 개선율**을 측정할 때
- ✅ **발표 자료용 기기별 성능 데이터**가 필요할 때

### 추천 워크플로우

```bash
# 1단계: 빠른 확인 (기기별 성능 차이)
./run-device-behavior-test.sh quick
# → 저사양/고사양 기기에서 PDF vs Queue 성능 차이 빠르게 파악 (4회, ~7분)

# 2단계: 특정 기기 집중 분석
node bench/bench-device-behavior.js \
  --url1 "..." --url2 "..." \
  --devices "low"
# → 저사양 기기만 집중 분석 (2회, ~3분)

# 3단계: 통계적 검증 (LongTask 반복 측정)
./run-25-tests.sh
# → 같은 조건에서 25회 반복으로 신뢰도 높은 평균 계산
```

### 성능 최적화 팁

기기별 벤치마크 사용 시:

1. **Headless 모드 사용** (기본값)
   - GUI 없이 실행되어 더 빠름
   - 백그라운드 실행 가능

2. **필요한 기기만 선택**
   ```bash
   # 전체 테스트 (6회) 대신
   # 핵심 기기만 테스트 (4회)
   ./run-device-behavior-test.sh quick
   
   # 또는 특정 기기만
   ./run-device-behavior-test.sh low-device  # 2회만
   ```

3. **병렬 실행하지 마세요**
   - CPU throttling이 정확하지 않을 수 있음
   - 순차 실행 권장

4. **안정적인 환경에서 실행**
   - 다른 앱 최소화
   - 백그라운드 작업 중지
   
5. **bench-pdfjs-longtasks.js와 동일한 패턴**
   - 두 벤치마크는 같은 현실적 패턴 사용
   - 결과 비교 및 교차 검증 가능

