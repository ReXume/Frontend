<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>PDF.js Render Bench Harness</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    #log { white-space: pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; background:#111; color:#ddd; padding:12px; border-radius:8px; }
    canvas { display:block; margin: 16px 0; box-shadow: 0 1px 6px rgba(0,0,0,.15); }
  </style>
</head>
<body>
  <h1>PDF.js Render Bench Harness</h1>
  <div id="info"></div>
  <div id="log"></div>

  <!-- PDF.js 라이브러리 로드 (UMD) -->
  <script src="/public/pdf.min.js"></script>
  
  <script type="module">
    // ----- URL Params -----
    const params = new URLSearchParams(location.search);
    const pdfUrl     = params.get('pdf');
    const scale      = parseFloat(params.get('scale') || '1.5');
    const rotation   = parseInt(params.get('rotation') || '0', 10);
    const maxPages   = parseInt(params.get('pages') || '10', 10);
    const rootMargin = params.get('rootMargin') || '200px';
    const threshold  = parseFloat(params.get('threshold') || '0.05');

    if (!pdfUrl) {
      document.querySelector('#info').textContent = 'Add ?pdf=<url> to the URL.';
    } else {
      document.querySelector('#info').textContent = `PDF: ${pdfUrl} | scale=${scale} | pages=${maxPages}`;
    }

    // ----- LongTask Observer (approx TBT) -----
    let longTaskSum = 0;
    const longTaskObserver = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === 'longtask') {
          longTaskSum += Math.max(0, entry.duration - 50);
        }
      }
    });
    try { longTaskObserver.observe({ entryTypes: ['longtask'] }); } catch {}

    // ============================================
    // pdfjs-dist: UMD 전역 변수 사용
    // ============================================
    const pdfjs = window.pdfjsLib;
    
    if (!pdfjs) {
      document.querySelector('#info').textContent = 'PDF.js 라이브러리를 로드할 수 없습니다.';
      throw new Error('pdfjsLib not loaded');
    }

    // ✅ 워커도 public 폴더의 파일 사용
    pdfjs.GlobalWorkerOptions.workerSrc = '/public/pdf.worker.min.js';

    const { getDocument } = pdfjs;

    
    const logEl = document.querySelector('#log');
    const log = (s) => { logEl.textContent += s + '\n'; };

    const tStart = performance.now();
    const loadingTask = getDocument({
      url: pdfUrl,
      cMapUrl: '/node_modules/pdfjs-dist/cmaps/',
      cMapPacked: true
    });
    const pdf = await loadingTask.promise;
    const total = pdf.numPages;
    const targetPages = Math.min(total, maxPages);

    const metrics = [];
    const container = document.createElement('div');
    document.body.appendChild(container);

    // ----- IntersectionObserver (가시 페이지 선별) -----
    const visibleSet = new Set();
    const observer = new IntersectionObserver((entries) => {
      for (const e of entries) {
        if (e.isIntersecting) {
          visibleSet.add(e.target);
          maybeKick();
        } else {
          visibleSet.delete(e.target);
        }
      }
    }, { root: null, rootMargin, threshold });

    // ----- 간단 큐 + 동시성 제한 -----
    const queue = [];
    let inFlight = 0;
    const MAX_CONCURRENCY = 2;

    function enqueue(task) { queue.push(task); maybeKick(); }

    async function maybeKick() {
      while (inFlight < MAX_CONCURRENCY && queue.length) {
        // 가시 우선 + 페이지 번호 순
        queue.sort((a, b) => {
          const av = visibleSet.has(a.host) ? 1 : 0;
          const bv = visibleSet.has(b.host) ? 1 : 0;
          return (bv - av) || (a.pageNumber - b.pageNumber);
        });
        const task = queue.shift();
        if (!task) break;
        inFlight++;
        try { await task.run(); } catch (e) { console.error(e); }
        inFlight--;
      }
    }

    // ----- 페이지 DOM 준비 & 작업 등록 -----
    for (let i = 1; i <= targetPages; i++) {
      const host = document.createElement('div');
      host.style.minHeight = '1000px';
      host.style.position = 'relative';
      const canvas = document.createElement('canvas');
      canvas.style.display = 'block';
      host.appendChild(canvas);
      container.appendChild(host);
      observer.observe(host);

      enqueue({
        host,
        pageNumber: i,
        run: async () => {
          const label = `p${i}`;
          const t0 = performance.now();
          const page = await pdf.getPage(i);
          const t1 = performance.now();
          const viewport = page.getViewport({ scale, rotation });

          const ctx = canvas.getContext('2d');
          canvas.width  = Math.ceil(viewport.width);
          canvas.height = Math.ceil(viewport.height);

          const renderTask = page.render({ canvasContext: ctx, viewport });
          await renderTask.promise;
          const t2 = performance.now();
          await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
          const t3 = performance.now();

          metrics.push({
            page: i,
            getPageMs: +(t1 - t0).toFixed(1),
            renderMs:  +(t2 - t1).toFixed(1),
            paintMs:   +(t3 - t2).toFixed(1),
            totalMs:   +(t3 - t0).toFixed(1),
          });
          log(`${label} getPage=${(t1-t0).toFixed(1)}ms render=${(t2-t1).toFixed(1)}ms paint=${(t3-t2).toFixed(1)}ms total=${(t3-t0).toFixed(1)}ms`);
        }
      });
    }

    // ----- 전체 완료 대기 (간단 폴링) -----
    const waitAll = () => new Promise((resolve) => {
      const id = setInterval(() => {
        if (metrics.length >= targetPages && inFlight === 0) {
          clearInterval(id);
          resolve();
        }
      }, 100);
    });
    await waitAll();

    const tEnd = performance.now();
    const summary = {
      pdfUrl,
      pagesMeasured: targetPages,
      scale,
      totalTimeMs: +(tEnd - tStart).toFixed(1),
      avg: {
        getPageMs: +(metrics.reduce((s,m)=>s+m.getPageMs,0)/metrics.length).toFixed(1),
        renderMs:  +(metrics.reduce((s,m)=>s+m.renderMs,0)/metrics.length).toFixed(1),
        paintMs:   +(metrics.reduce((s,m)=>s+m.paintMs,0)/metrics.length).toFixed(1),
        totalMs:   +(metrics.reduce((s,m)=>s+m.totalMs,0)/metrics.length).toFixed(1),
      },
      longTaskBlockingMsApprox: +longTaskSum.toFixed(1),
      metrics
    };

    // ----- (옵션) 스크롤 타임라인 로그 -----
    window.addEventListener('scroll', () => {
      console.log('[scroll]', performance.now());
    });

    // ----- Puppeteer로 결과 노출 & 종료 신호 -----
    window.benchResults = summary;
    window.dispatchEvent(new Event('bench-done'));

    log('\n=== SUMMARY ===');
    log(JSON.stringify(summary, null, 2));
  </script>
</body>
</html>
